op_mode:
    name opmode 'use'
    -> ([name 'as'] module <exp>* (keyword_name ':' <exp>+)* NEWLINE)+


module/function/subroutine declaration
    name ('module' | 'function' | 'subroutine')
        - function name follows identifier typing rules to specify the return
          type of the function
        - modules/subroutines have no return type
        - all param_names (but not keyword_names) follow identifier typing rules
    -> param_name*
        - required positional parameters
    -> (param_name ['=' <exp>])*
        - optional positional parameters
        ? do we really want these???
            - no (for now)
    -> ([keyword_name ':'] param_name ['=' <exp>])*
        - the keyword_names are required in the call
        - keyword_names in the call may be in a different order
        - keyword_names lacking a default value are required
        - default and non-default keywords may be declared in any order


function/subroutine declarations are followed by:
    ['returning' type_name+]
    -> type_declaration*
    -> (name 'is' type_name)*
    -> ('dim' name '[' <exp> ']')*  # name may have been typed by name is type
    -> block
    -> labeled_block*


type_declaration:
    - 'type' type_name 'is' 'function' ['taking' type_name+]
    -> 'returning' type_name+
    - 'type' type_name 'is' 'subroutine' ['taking' type_name+]


module declarations are followed by:
    type_declaration*
    variable decls
    function/subroutine declarations


module/function/subroutine call:
    - function calls with arguments are not simple_exp, ( ) required for nested
      calls within arguments:
        - foo 11 (bar 22)
        - but if bar takes no arguments:
            - foo 11 bar
    - name <simple_exp>* (keyword_name ':' <simple_exp>)*


simple_exp:
    - literal
    - variable (local or global)
        - calls result if it's a function of no arguments, use 'foo to quote
    - label
        - does _not_ call result
    - '\'' ( function | label )
        - does _not_ call result if it's a function of no arguments
    - '-'<simple_exp>
    - 'not' <simple_exp>
    - <simple_exp> '[' <exp> ']'
    - <simple_exp> '.' <identifier>
    - '(' <exp> ')'


exp (in descending precedence order, left to right unless stated otherwise):
    - <simple_exp>
    - <simple_exp> <simple_exp>+
    - <exp> '^' <exp> (right to left)
    - <exp> '*' <exp>
    - <exp> '/' <exp> (right to left)
    - same precedence:
        - <exp> '+' <exp>
        - <exp> '-' <exp>
    - same precedence (overlapping):
        - <exp> '<' <exp>
        - <exp> '<=' <exp>
        - <exp> '<~=' <exp>
        - <exp> '>' <exp>
        - <exp> '>=' <exp>
        - <exp> '>~=' <exp>
    - same precedence (overlapping):
        - <exp> '==' <exp>
        - <exp> '~=' <exp>
        - <exp> '!=' <exp>
        - <exp> '<>' <exp>
        - <exp> '!~=' <exp>
        - <exp> '<~>' <exp>


simple_statement:
    - <simple_exp>+
        - verifies that prepared and called in-use flags are both false.
        - sets called flag
    - 'prepare' <simple_exp>+
        - checks and sets prepared flag.
    - 'reuse' <simple_exp>
        - verifies prepared flag is set.
            - can not be used on un-prepared parameterless subroutines.
        - verifies called flag is not set.
        - sets called flag.
    - 'release' <simple_exp>
        - checks and resets prepared flag.
    - variable '=' <exp>
    - variable+ '=' <simple_exp>+
        - calling return^ in called function sends return addr as first value.
            - the return addr is type foo^
            - all arguments to return^ come after the return addr.
    - variable '<op>=' <exp>
        - e.g.
            - i += 1


final_simple_statement:
    - <simple_statement>
    - call 'returning_to:' <simple_exp>
    - 'reuse' <simple_exp> 'returning_to:' <simple_exp>
    - goto <simple_exp> <simple_exp>*
    - return <simple_exp>* ['to' <simple_exp>]
        - checks and resets called flag


statement:
    - <simple_statement> NEWLINE
    - <dlt>


final_statement:
    - <final_simple_statement> NEWLINE
    - <final_dlt>


block:
    - <statement>* <final_statement>


labeled_block:
    <label> param_name* ':' <block>


dlt:
    DIVIDER NEWLINE
    (<exp> '|' ('y'|'Y'|'n'|'N'|'-')+ NEWLINE)*
    DIVIDER NEWLINE
    <action>+
    DIVIDER NEWLINE


final_dlt:
    DIVIDER NEWLINE
    (<exp> '|' ('y'|'Y'|'n'|'N'|'-')+ NEWLINE)*
    DIVIDER NEWLINE
    <final_action>+
    DIVIDER NEWLINE


action:
    <simple_statement> '|' ('x'|'X'|' ')+ NEWLINE
    (<simple_statement> NEWLINE)*


final_action:
    - <final_simple_statement> '|' ('x'|'X'|' ')+ NEWLINE
    - <simple_statement> '|' ('x'|'X'|' ')+ NEWLINE
      (<simple_statement> NEWLINE)*
      <final_simple_statement> NEWLINE

