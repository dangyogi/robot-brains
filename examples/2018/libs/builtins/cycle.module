# The cycle module orchestrates the whole program!

module

type label_l_t is label taking label_t

tasks is label_t
what_next is label_t

dim tasks[100][2]

dim inum_tasks[2]


subroutine run
    run_all "init"

  label wait_for_start
    ======================================================================
    | NYY | isAlive?
    | -NY | isStarted?
    ======================================================================
    |  X  | goto wait_for_start
    |   X | run_all "start"
    | X   | goto run_stop
    ======================================================================

  label run_stop
    run_all "stop"
    return


subroutine run_all name$
    next_subr is subr_t
    p_config is p_config_t

    set i_current to: 0
    set i_next to: 1
    set i_task to: 0
    set inum_tasks[0] to: 0
    set inum_tasks[1] to: 0

    set p_config to: {get_subroutines_by_name name$}

    # This calls c_config before returning:
    p_config c_yield: c_yield c_done: c_done c_config: c_config

    goto p_next


subroutine c_config ?p_next: p_next ?p_done: p_done ?p_config: p_config
    # This only gets called while the producer is still active, so always
    # update what_next.
    p_next is label_t
    p_done is subr_t
    set what_next to: p_next 
    return


  label c_yield next_subr
    next_subr returning_to: what_next


  label c_done
    set what_next to: run_next_task 
    goto run_task


  label swap_task_lists
    # swap i_next into i_current, re-init and run all i_current tasks
    ======================================================================
    | NYY | isAlive?
    | -YN | inum_tasks[i_next] == 0
    ======================================================================
    | XX  | return from: run_all   # no more tasks scheduled, all done!
    |   X | # swap i_next and i_current
    |     | set i_next to: i_current
    |     | set i_current to: (1 - i_next)
    |     | # start over on the new task list
    |     | set i_task to: 0
    |     | set inum_tasks[i_next] to: 0
    |     | goto run_task  # skip i_task increment
    ======================================================================


  label run_next_task
    i_task += 1
    goto run_task


  label run_task
    ======================================================================
    | YN | i_task < inum_tasks[i_current]
    ======================================================================
    | X  | goto tasks[i_task][i_current] # always goes to what_next when
                                         # task is done
    |  X | goto swap_task_lists
    ======================================================================


subroutine next
    # Returns on next cycle
    done
    push_task ret_pointer returning_to: what_next


subroutine push_task task ?task_list: itask_list
    task is label_t
    ======================================================================
    | NY | got? task_list:
    ======================================================================
    | X  | set itask_list to: i_next
    |  X | continue
    ======================================================================
    ======================================================================
    | YN | inum_tasks[itask_list] >= 100
    ======================================================================
    | X  | abort "task list overflow"
    |  X | set tasks[inum_tasks[itask_list]][itask_list] to: task
    |    | inum_tasks[itask_list] += 1
    |    | return
    ======================================================================


subroutine schedule subr
    # Start a new thread
    subr is subroutine

    # This will return from this subroutine to let the main thread continue in
    # this cycle
    push_task ret_pointer task_list: i_current

    # Start the new thread
    subr returning_to: what_next

